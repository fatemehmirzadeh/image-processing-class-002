# task 6

## filtering

### توضیحات:
در این تمرین هدف این است که برنامه نوشته شود که با فیلتر همسایگی 4 گانه کار کند (بالا، پایین، چپ، راست) و پیکسل مرکزی را از حاصل جذر همسایه ها تغییر مقدار دهد. در این برنامه ابتدا با بایستی یک padding به تصویر اضافه شود که باعث حدف شدن exception ها بشود. لذا با توجه به تابعی از padding که در تمرین دوم تحت عنوان pdding2 ارائه شد، تصویر به این تابع وارد می‌شود و بعد از آن عملیات فیلترینگ هماسیگی انجام می‌شود. لذا کد این برنامه به ‌صورت زیر است:

```
1)clc;
2)clear all;
3)close all;


4)pic0=imread("photo_2022-03-30_21-00-33.jpg");
5)figure(1);
6)imshow(pic0)

7)if size(pic0,3)~=1
8)    pic0=rgb2gray(pic0);
9)    figure(2);
10)    imshow(pic0);
11)    pic1=padding2(pic0);
12)    figure(3);
13)    imshow(pic1)
14)    row=size(pic1,1);
15)    col=size(pic1,2);
16)    for i0=2:(row-1)
17)        for i1=2:(col-1)
18)            sum=floor(sqrt(double(pic1(i0,(i1-1)))))+...
19)                floor(sqrt(double(pic1((i0+1),i1))))+...
20)                floor(sqrt(double(pic1(i0,(i1+1)))))+...
21)                floor(sqrt(double(pic1((i0-1),i1))));
22)            avr=uint8(sum/4);
23)            pic1(i0,i1)=avr;
24)        end
25)    end
26)else
27)    pic1=padding2(pic0);
28)    figure(3);
29)    imshow(pic1)
30)    row=size(pic1,1);
31)    col=size(pic1,2);
32)    for i0=2:(row-1)
33)        for i1=2:(col-1)
34)            sum=floor(sqrt(double(pic1(i0,(i1-1)))))+...
35)                floor(sqrt(double(pic1((i0+1),i1))))+...
36)                floor(sqrt(double(pic1(i0,(i1+1)))))+...
37)                floor(sqrt(double(pic1((i0-1),i1))));
38)            avr=uint8(sum/4);
39)            pic1(i0,i1)=avr;
40)        end
41)    end
42)end
43)figure(4);
44)imshow(pic1);
```

همانطور که بیان شد در خط 11 تصویر وارد تابع padding می‌شود و بعد از آن وارد مرحله فیلترینگ می‌شود. حال در ادامه در خط 14 و 15 سایز تصویر(تعداد ستون‌ها و ردیف‌ها) اندازه‌گیری می‌شود. در مرحله بعد جهت پیمایش تک تک پیکسل ها و اعمال پردازش بر روی آن دو حلقه for تو در تو در اختیار داریم. در این تصویر چون که padding اضافه شده باید عملیات پردازش از پیکسل(2و2) شروع کند و تا ستون و ردیف یکی به آخر منتهی شود. در 18، 19، 20 و 21  چهار همسایه بالا و پایین چپ و راست در نظر گرفته می‌شود و جذر هر کدام بایستی در نظر گرفته شود. اما چون جنس تصویر از uint8 است نمیتوان جذر گرفت و باید قبل از جذر آن را به double تبدیل کرد و سپس جذر گرفته شود و سپس جز صحیح آن حساب می شود تا بتوان یک عدد صحیح در اختیار داشت. سپس 4 مقدار حاصل شده را باهم جمع کرده و در خط 22 میانگیری می‌شود. و آن دوباره به uint8 تبدیل شده تابتوان مقادیر پیکسل ها را به صورت 8 بیتی در اختیار داشت. در نهایت در خط 44 نتیجه نهایی نمایش داده می‌شود. توضیحات بقیه کد ها تکراری هستند و در توضیحات قبلی چندین بار توضیح داده شده است.

**تصویر ورودی**


![image](https://user-images.githubusercontent.com/95109502/161375467-fc951a7f-9479-4172-975d-3f16a52e7a09.png)

**تصویر خاکستری**



![image](https://user-images.githubusercontent.com/95109502/161375722-524ab845-3645-41b4-afb0-3f905b1ce461.png)

