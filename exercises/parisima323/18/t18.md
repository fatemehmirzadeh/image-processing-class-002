```

clc
clear all
close all
img= rgb2gray( imread('onion.jpg'));
Hidimg=rgb2gray( imread('poem.jpg'));
[x1,y1,z1]= size(img);
[x2,y2,z2]= size(Hidimg);
if (x2>x1)|(y2>y1)
   Hidimg= imresize(Hidimg,[x1,y1]);
else
   Hidimg1(x2+x1-x2,y2+y1-y2)=255;
end 


```

دو شکل  تصویر و تصویر پنهان را خوانده و ابعاد انهارا محاسبه میکنیم –
 رابطه ابعاد دو شکل میبتواند سه حالت باشد  
الف ) یا هر دوشکل با هم همسایزند
ب)یا شکل پنهان کوچکتر است  در این حالت هم میتوان تغییر ساز داد و یا  خانه هایی که با هم اختلاف دارند را یک مقدار ثابت مثل 0 یا 255 و یا مقادیر خود تصویر اصلی را قرار داد
ج) یا شکل پنهان بزرگتر است که میتوان تغییر سایز داد ( میتواند این بزرگی از یک بعد مثلا صرفا x یا y باشد و حتی  تصویر پنهان از عرض بزرگ تر و از طول کوچکتر باشد که در این صورت تلفیق الف و ب یعنی تغییر سایز و کاشی کردن نیز استفاده میتوان کرد که ما برای راحتی کد همه این موارد را صرف نظر کرده و از هر دو بعد طول و عرض تغییر سایز میدهیم در صورتی که یکی از انها بزرگتر باشد)



```


b7=double(bitget(img, 8));
b6=double(bitget(img, 7));
b5=double(bitget(img, 6));
b4=double(bitget(img, 5));
b3=double(bitget(img, 4));
b2=double(bitget(img, 3));
b1=double(bitget(img, 2));
b0=double(bitget(img, 1));
H8=double(bitget(Hidimg, 8));
H7=double(bitget(Hidimg, 7));


```

تابع bitget  از توابع پیشفرض خود متلب هست که دو مقدار ورودی  اسم تصویر یا ماتریس و شماره بیت مورد نظر را گرفته و مجموعه بیت های درخواستی را باز میگرداند  ما قصد داریم تصویر نهان نگاری شده به این صورت باشد که شش بیت با ارزش 7-2 از تصویر اصلی و دو بیت 1-0 از تصویر پنهان باشد برای همین دو بیت پر ارزش  تصویر پنهان را با نام h7 , h8 و بیت های تصویر اصلی را  از b7 تا b2 نام گذاری کرده ایم


```

temp=b7 .* 128+b6 .* 64+b5 .*32+b4 .*16 + b3 .*8 + b2 .*4+H8 .*2 +H7;

```

حالا ما 8 تا بیت پلین داریم و میخواهیم تصویر را بازسازی کنیم هر بیت پلین یک ماتریس متشکل از 0 و 1 میباشد و هر بیت پلین ارزش خاض خودش را دارا هست  
مثلا عدد 300 را اگر بخواهیم به صورت باینری بنویسیم داریم 10000010 یا عدد 5 خواهد بود 00000101 که روند محاسبه به این صورت هست 
بیت هفتم یا چپ ترین بیت ارزش 128 و بیت ششم ارزش 64 بیت پنجم ارزش 32 بیت چهارم ارزش 16 بیت سوم ارزش 8 بیت دوم ارزش 4 بیت اول ارزش 2 و بیت صفر ارزش 1 را دارد 
حال برای برگرداندن عکس باید عکس این روند را طی کنیم یعنی از باینری به دسیمال برویم پس هر بیت پلین را در ارزش گفته شده ضرب و با حاصل ضرب باقی بیت پلین ها جمع میشود یعنی ما دنباله ارقامی مثل 10001100 را داریم و 1*128+0*64+0*32+0*16+1*8+1*4+0*2+0*1= 140 میشود 


```

figure;
imshow(b7)
title('bit plane 7');


```

 بیت پلین 7 ام رسم میکنیم 
 
```

figure;
subplot (2,4,1)
imshow(img);
title(' original img');
subplot (2,4,2)
imhist(img)
title(' histogram original img');
subplot (2,4,3)
histeq(img)
title('histogram equalisation orginal img');
subplot (2,4,4)
imhist(histeq(img))
title(' orginal img after histogram equalization );
subplot (2,4,5)
imshow(uint8(temp));
title('steganography');
subplot (2,4,6)
imhist(temp)
title(' histogram steganography');
subplot (2,4,7)
histeq(temp)
title(' histogram equalisation steganography');
subplot (2,4,8)
imhist(histeq(temp))
title(' steganography  img after histogram equalisation ');


```

کد بالا برای نمایش تصاویر اصلی و تصویر نهان نگاری شده هیستو گرام های دو تصویر و  همچنین  بعد از بهبود هیستوگرام و هیستوگرام جدید تصویر بهبود یافته را مشهاده میکنید 
هیستو گرام های تصاویر اصلی و نهان نگاری شده اگرچه این تصاویر از لحاظ بصری تفاوتی نمیکنند  ، متفاوت هستند چرا که مقادیر رنگ ها تغییر یافته مثلا اگر یک پیکسل در تصویر اولیه رنگ 5 داشته باشد در این صورت به صورت  00000101 میباشد ما شش بیت اول این مقدار را نگه داشته و باقی را دور میریزیم یعنی 000001 
حالا به جای دو بیت دور ریخته  دو بیت هفت و شش تصویر پنهان را میگذاریم و اگر در همان نقطه مقدار رنگی تصویر پنهانی 140 باشد داریم  10001100 که دو بیت ارزشمند ان 10 هست حالا این دو مقدار را در سمت راست شش بیت تصویر اصلی گذاشته و داریم 00000110 که این همان باینری عدد 6 هست  و چشم انسان تفاوت بین رنگ 5 و 6 را نمیتواند تشخیص دهد اما در هیستو گرام جایگاه و تعداد بیت ها تغییر میکند


```
Compic1=b7 .* 128+b6 .* 64;
Compic2=b7 .* 128+b6 .* 64+b5 .*32 ;
Compic3=b7 .* 128+b6 .* 64+b5 .*32+b4.*16+b3.*8 ;


```

برای فشرده سازی میتوان بسته به نرخ فشرده سازی تعدادی از بیت هارا از بین برد   هرچی تعداد بیت های دور انداخته بیشتر حجم فشرده سازی نیز بیشتر و تصویر با شدت بیشتری تخریب میشود

```
figure;
subplot (1,4,1)
imshow(uint8(Compic));
title('Compressed pic b7-b6');
subplot (1,4,2)
imshow(uint8(Compic));
title('Compressed pic b7-b6-b5 ');
subplot (1,4,3)
imshow(uint8(Compic));
title('Compressed pic b7-b6-b5-b4-b3');
subplot (1,4,4)
imshow(img);
title('orginal pic');


```

نتیجه برنامه:


![p1](https://user-images.githubusercontent.com/71499851/169615552-c989c2f9-d603-4123-a602-d3bbc8a404ce.jpg)



![p2](https://user-images.githubusercontent.com/71499851/169615584-e2903f4d-a1e2-4d70-9543-07bc1221b8aa.jpg)



![p3](https://user-images.githubusercontent.com/71499851/169615603-74d2d9f7-c816-4aaa-8edc-02710093f03d.jpg)


