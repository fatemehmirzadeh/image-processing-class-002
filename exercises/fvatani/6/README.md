```
clc;
clear all;
close all;
```
از دستورات clear all، clc و close all  به ترتیب برای پاک کردن صفحهCommand Window، حذف متغیرها و بستن پنجره ها استفاده شده است.
```
image=imread('pears.png'); 
image=rgb2gray(image); 
p=1;
pad=uint8(zeros(size(image)+2*p));  
result_image=uint8(zeros(size(image)));  
```
تصویر دریافت شده وازRGB به تصویر خاکستری تبدیل می‌شود. در صورتیکه تصویر خاکستری است این خط کامنت شود. پنجره فیلترگذاری 3*3 است و میزان padding برابر 3/2=1 می‌شود پس مقدار متغییر p برابر یک قرار داده شده است. مقدار padding را علاوه بر پیکسل‌های اصلی تصویر در بر بگیرد. padding  در سمت چپ و راست و بالا و پایین باید اضافه گردد بنابراین به پیکسل‌هایی اصلی تصویر دو برابر مقدار p باید اضافه شود( در این مسئله باید به هر سمت تصویر 1 پیکسل اضافه شود. درنهایت به x و y  هرکدام باید 2 پیکسل اضافه شود). تابع size برای استخراج اندازه تصویر(ماتریس) بکار رفته است و سایز کامل ماتریس (تعداد سطر و ستون) را بر می‌گرداند. با کمک تابع zeros یک ماتریس که حاوی درایه های صفر است با اندازه مشخص شده ساخته می‌شود. uint8 برای تبدیل ورودی به یک عدد صحیح 8 بیتی بدون علامت استفاده شده است. تصویر نهایی که حاصل از فیلترگذاری است در result_image ذخیره می‌شود و مقدار سطر و ستون آن با تصویر اصلی برابر است. در ابتدا تمام پیکسل‌های متغیر result_image صفر هستند.
```
for x=1:size(image,1)
     for y=1:size(image,2)
          pad(x+p,y+p)=image(x,y); 
     end
end
```
تصویر اصلی به کمک دو حلقه که شمارنده آنها از یک تا طول و عرض تصویر پیش می‌رود پیمایش شده و مقدار پیکسل‌ها در pad_image ذخیره می‌شود. از آنجا که p ستون و p سطر در ابتدا و انتها و بالا و پایین تصویر برای padding  باید خالی بماند و پیکسل ها در وسط  قرار گیرند مقدار x و y در pad_image با p جمع شده‌است.  
```
for x=1:size(result_image,1)
     for y=1:size(result_image,2)
            result = 0;
            
            result = sqrt(double(pad(x+p,y)))+ sqrt(double(pad(x,y+p)))+ sqrt(double(pad(x+p+1,y+p)))+ sqrt(double(pad(x+p,y+p+1)));
            result_image(x,y)= floor(result);
                       
     end
end
```

تصویر اصلی (image): 
(x , y) |   |   |  
--- | --- | --- |
  |   |   |   
  |   |   |
  
 تصویرpad:
(x , y)|(x , y+p)|(x , y+p+1)|
--- | --- | --- |
(x+p , y)|(x+p , y+p)|(x+p , y+p+1)| 
(x+p+1 , y)|(x+p+1 , y+p)|(x+p+1 , y+p+1)|

در این حلقه به اندازه طول و عرض result_image که مقدارش برابر با تصویر اصلی است پیمایش انجام می‌شود. مقدار پیکسل (x,y) تصویر نتیجه باید از مقادیر پیکسل‌های همسایه بدست آید. باتوجه به padding مقدار x,y تصویر pad از تصویر اصلی p=1 جلوتر است. یعنی پیکسل (x,y) تصویر اصلی برابر با پیکسل (x+p,y+p) تصویر pad هست. حال به سراغ مشخص کردن همسایه‌ها در تصویر pad میرویم. پیکسل‌های سطر بالای (x+p,y+p) مقدار x شان یک واحد(p) کم می‌شود و مقدار x در سطر پایین نسبت به پیکسل مرجع یک واحد اضافه می‌شود. تغییرات y هم به این صورت است که وقتی یک ستون به جلو می‌رویم مقدارش با یک جمع می‌شود و اگر یک ستون نسبت به پیکسل مرجع عقب بیایم به مقدار y می‌رسیم. 
باتوجه به اینکه پیکسل مرکزی از حاصل جذر همسایه ها باید تغییر مقدار دهد مقدار sqrt هر پیکسل با تابع sqrt جذرگرفته شده و مجموع در result ذخیره شده است. از آنجا که امکان دارد حاصل عدد صحیح نباشد از تابع floor برای رند کردن استفاده شده است. تابع sqrt برای ورودی از نوع unit8 تعریف نشده است برای رفع این مشکل از مقادیر پیکسل‌ها به double تبدیل شده‌اند. 
```
figure,imshow(result_image);
```
خروجی نمایش داده می‌شود.

خروجی:
 ![image](https://github.com/semnan-university-ai/image-processing-class-002/blob/main/exercises/fvatani/6/tamrin6.png)














